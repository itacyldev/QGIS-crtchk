# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CartoDruidSyncDialog
                                 A QGIS plugin
 Plugin to synchronize SQLite databases to Cartodruid Synchronization services at ITACyL
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-01-20
        git sha              : $Format:%H$
        copyright            : (C) 2023 by ITACyL
        email                : gustavo.rio@itacyl.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import sqlite3

from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QListWidgetItem
from qgis.PyQt import uic

if os.environ.get("TEST_RUNNING", 0):
    import db_manage as dbm
    from plugin_settings import resolve_path
else:
    from . import db_manage as dbm
    from .plugin_settings import resolve_path

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
# FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'cartodruid_sync_dialog_base.ui'))
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'cartodruid_sync_wizard.ui'))


class TableFilterScreen:
    def __init__(self, dialog, listener=None):
        """Constructor."""
        self.dlg = dialog
        self.listener = listener

        self.__initGui()

        self.wks_config = None
        self.table_list = None
        self.selection_list = None
        self.plugin_confs = None

    def __initGui(self):

        # connect actions
        self.dlg.btn_add.clicked.connect(self.__add_selected)
        self.dlg.btn_add_all.clicked.connect(self.__add_all)
        self.dlg.btn_remove.clicked.connect(self.__remove_selected)
        self.dlg.btn_reload.clicked.connect(self.reload_tables)
        self.dlg.chk_apply_filter.clicked.connect(self.__enable_form_fields)

    def load_settings(self, wks_config):
        is_filter_checked = wks_config is not None and wks_config.table_filter is not None
        self.dlg.chk_apply_filter.setChecked(is_filter_checked)
        self.__enable_form_fields()

        table_filter = wks_config.table_filter
        is_checked = table_filter is not None
        self.dlg.chk_apply_filter.setChecked(is_checked)
        print(f"Table filter found: {table_filter}")
        # load table_names into selection combo
        if table_filter and len(table_filter) > 0:
            self.__add_tables_to_selection(table_filter)
            # for table_name in table_filter:
            #     self.dlg.lstw_selectionList.addItem(QListWidgetItem(table_name))

    def __add_selected(self):
        # get selected tables and check if some of them don't have the trigger and ask to add them
        ok_tables = []
        no_trigger_tables = []
        for item_idx in self.dlg.lstw_tableList.selectedIndexes():
            table_name, has_index = self.table_list[item_idx.row()]
            if has_index:
                ok_tables.append(table_name)
            else:
                no_trigger_tables.append(table_name)

        # add ok tables to selected list
        self.__add_tables_to_selection(ok_tables)

        # msg = "Estas tablas no tienen asociado un trigger de actualización, este trigger es necesario para registrar " \
        #       "los cambios: \n {} \n¿Deseas crearlos?".format("\n".join(no_trigger_tables))
        #
        # result = QMessageBox.question(None, "Ha seleccionado tablas no monitorizadas", msg,
        #                               QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        # if result == QMessageBox.Yes:
        #     # create trigger and add tables to list
        #     conn = sqlite3.connect(self.get_db_file())
        #     try:
        #         dbm.create_update_trigger()
        #     finally:
        #         if conn:
        #             conn.close()

    def __add_tables_to_selection(self, table_list):
        current_selection = self.__get_current_selection()
        for table_name in table_list:
            if table_name not in current_selection:
                self.dlg.lstw_selectionList.addItem(QListWidgetItem(table_name))

    def __get_current_selection(self):
        current_selection = []
        for i in range(self.dlg.lstw_selectionList.count()):
            current_selection.append(self.dlg.lstw_selectionList.item(i).text())
        return current_selection

    def __enable_form_fields(self):
        enable = self.dlg.chk_apply_filter.isChecked()
        fields = ['btn_add', 'btn_add_all', 'btn_remove', 'btn_reload']
        for f in fields:
            widget = getattr(self.dlg, f)
            widget.setEnabled(enable)

    def __add_all(self):
        all_tables = []
        for i in range(self.dlg.lstw_tableList.count()):
            all_tables.append(self.dlg.lstw_tableList.item(i).text())
        self.__add_tables_to_selection(all_tables)

    def __remove_selected(self):
        current_selection = self.dlg.lstw_selectionList.selectedIndexes()
        for idx in reversed(current_selection):
            self.dlg.lstw_selectionList.takeItem(idx.row())

    # def __select_layer(self):
    #     # disable file widget
    #     self.fileWidget.setEnabled(False)
    #     self.combo_layer_name.setEnabled(True)
    #
    # def __select_file(self):
    #     self.fileWidget.setEnabled(True)
    #     self.combo_layer_name.setEnabled(False)

    def reload_tables(self):
        file_path = self.dlg.fileWidget.filePath().replace('\\', '/')
        if not file_path:
            self.dlg.lstw_tableList.clear()
            self.dlg.lstw_selectionList.clear()
            return
        # leer las tablas de la BD
        conn = sqlite3.connect(file_path)
        try:
            table_names = dbm.get_table_list(conn)
            self.table_list = []
            item_list = []
            # check if tablas has an update trigger
            for name in table_names:
                has_trigger = dbm.has_update_trigger(conn, name)
                self.table_list.append((name, has_trigger))
                icon = QIcon(resolve_path("assets/check-mark-16.png")) if has_trigger else QIcon(
                    resolve_path("assets/x-mark-16.png"))
                self.dlg.lstw_tableList.addItem(QListWidgetItem(icon, name))
        finally:
            if conn:
                conn.close()

    def get_table_filter(self):
        if not self.dlg.chk_apply_filter.isChecked():
            return None
        else:
            return self.__get_current_selection()
